"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIBase = void 0;
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("../constants");
const logger_1 = require("../logger");
const ORG_TOKENS = new Map();
class APIBase {
    token;
    name;
    orgName;
    options;
    /** @protected */
    log;
    axios;
    get baseUrls() {
        return constants_1.ENVS[this.options.env || 'prod'];
    }
    /**
     * @param token the apps token
     * @param name the name of the api
     * @param orgName the name of the org in reference (unique)
     * @param options the apps options
     */
    constructor(token, name, orgName, options) {
        this.token = token;
        this.name = name;
        this.orgName = orgName;
        this.options = options;
        this.log = new logger_1.Logger(`kapp:${this.options.app}:${this.name}`);
        this.axios = axios_1.default.create();
        this.axios.interceptors.request.use(this._onRequest.bind(this), this._onError.bind(this));
        this.axios.interceptors.response.use(this._onResponse.bind(this), this._onError.bind(this));
    }
    /**
     * get an app auth token to make requests in an org
     * @param forceRefresh ignore cached values
     */
    async getToken(forceRefresh) {
        // used for development purposes to be removed later
        if (process.env.AUTH_TOKEN) {
            return process.env.AUTH_TOKEN;
        }
        if (!forceRefresh && ORG_TOKENS.has(this.orgName)) {
            return ORG_TOKENS.get(this.orgName);
        }
        try {
            const res = await axios_1.default.get(`${this.baseUrls.gateway}/v1/orgs/${this.orgName}/token`, {
                headers: {
                    'x-kustomer-app-client-id': this.options.clientId,
                    'x-kustomer-app-token': this.token
                }
            });
            ORG_TOKENS.set(this.orgName, res.data.data.attributes.token);
            return res.data.data.attributes.token;
        }
        catch (err) {
            this.log.error(err);
        }
    }
    /**
     * @private
     */
    async _onRequest(config) {
        const token = await this.getToken();
        if (!token) {
            throw new Error(`failed to get token for ${this.orgName}`);
        }
        return {
            ...config,
            headers: {
                ...config.headers,
                Authorization: `Bearer ${token}`
            }
        };
    }
    /**
     * @private
     */
    async _onResponse(res) {
        if (res.status >= 400 && res.status < 500) {
            this.log.warn(res.data);
        }
        else if (res.status === 500) {
            this.log.error(res.data);
        }
        return res;
    }
    _onError(error) {
        return Promise.reject(error);
    }
}
exports.APIBase = APIBase;
//# sourceMappingURL=base.js.map